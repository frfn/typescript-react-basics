The idea about `HoC` is to **`share`** different functionalities between components!

---

# HoC pt. 1 - special offer!

-   just created the `SpecialOffer.tsx` component

-   nothing special about it ... ðŸ‘€

---

# HoC pt. 2 - another form of HoC, the real way

Overkill for this app?!

-   we will wrap both `FoodCard.tsx` and `SpecialOffer.tsx` with it!

1. create a `/hoc` folder

2. create the `AddToCart.tsx` file

-   naming convetion for HoC is to start with `with`, ex. `withErrorHandler`, `withCustomHoC`

3. the ChildComponent must be of type `React.ComponentType<OriginalProps>`

-   passing in `{...props}` inside the `<ChildComponent>` so that the component will still contain all the props it has!

    -   `<ChildComponent {...props} />`

```
interface HiThere<T> {
	type: T;
}

interface Greeting extends HiThere<"A Greeting"> {
    formal: boolean
}

const beFormal: Greeting = {
    type: "A Greeting",
    formal: true
}
```

-   example to show that `AddToCartHOC` uses:
    -   `<ChildComponent {...props} />`
    -   `React.ComponentType` is ChildComponent
    -   `<OriginalProps>` is {...props}

4. **Just learn it for now!**

-   No need to get into the nitty gritty of things since.

5. Passing down the function

-   the component will pass down a function, the function WILL be a prop in the child component!

Rough visualization | **`NOT`** code

```
withAddToCart {
    onAddToCart: () => void

    FoodCard {
        props.onAddToCart: () => void
        since it comes from the parent
    }

}
```

6. Create an `interface` for the `onAddToCart` function and extend it to the `interface Props` in `FoodCard.tsx` and `SpecialOffer.tsx`

-   Now you can use the function because TS knows how to handle the function now, it tells it needs a `type CartItem` object!
